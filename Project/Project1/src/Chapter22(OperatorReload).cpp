#include <iostream>
#include <cstring>

#define _CRT_SECURE_NO_WARNINGS
using namespace std;

/*146. 运算符重载基础 - 让操作更方便，更美观

运算符重载把并不是什么新鲜的事情。
C语言当中 将 * 重载成解引用和乘法


C++将运算符重载扩展到自定义的数据类型(类），它可以让对象操作更美观。

例如字符串string用加号（+）拼接、cout用两个左尖括号（<<）输出。

【使用语法】
运算符重载函数的语法：返回值 operator运算符(参数列表);
运算符重载函数的返回值类型要与运算符本身的含义一致。
非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；
成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。
如果同时重载了非成员函数和成员函数版本，会出现二义性。


注意：
1）返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）
2）重载函数参数列表中的顺序决定了操作数的位置。
3）重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。
4）如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。
5）重载函数不能违背运算符原来的含义和优先级。
6）不能创建新的运算符。
7）以下运算符不可重载：
	sizeof             sizeof运算符
	.                  成员运算符
	.*                 成员指针运算符
	::                 作用域解析运算符
	?:                 条件运算符
	typeid            一个RTTI运算符
	const_cast        强制类型转换运算符
	dynamic_cast     强制类型转换运算符
	reinterpret_cast   强制类型转换运算符
	static_cast        强制类型转换运算符
8）以下运算符只能通过成员函数进行重载：
	=                赋值运算符
	()                函数调用运算符
	[]                下标运算符
	->               通过指针访问类成员的运算符

*/

// 业务需求： 添加两个成员的分数
class CGirl
{
private:
    int m_age;
    int m_score;

public:
    string m_score;

    // 默认构造
    CGirl()
    {
        m_age = 11;
        m_score = 20;
    }
    void show()
    {
        cout << "m_age = " << m_age << " m_score = " << m_score << endl;
    }
};

void test146_main()
{
    CGirl g;
    // g = g + 30; 没有实现重载是这个肯定是不行的
}

int main()
{
}
