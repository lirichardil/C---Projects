#include <iostream>
#include <string>

using namespace std;

/*38. sizeof(数据类型)

sizeof运算符用于求数据类型或变量占用的内存空间。
用于数据类型：sizeof(数据类型)
用于变量：sizeof(变量名) 或 sizeof 变量名

注意：
- 在32位和64位操作系统中，同一种数据类型占用的内存空间可能不一样。
- 字符串（string）不是C++的基本数据类型，用sizeof求它占用内存的大小没有意义。
- 32位中和64位的int 都是占4个字节，主要的区别是long， long在32位中占4字节，在64位占8字节
- 32位和64位的寻址单位不一样。 32位是4字节的寻址方式，64位则是8字节

*/
void test38()
{
    // 用于数据类型：sizeof(数据类型)
    // 用于变量：sizeof(变量名) 或 sizeof 变量名
    // C++常用的数据类型：整数（int）、浮点数（float和double）、字符（char）和布尔（bool）。
    cout << "sizeof(int)=" << sizeof(int) << endl;
    cout << "sizeof(float)=" << sizeof(float) << endl;
    cout << "sizeof(double)=" << sizeof(double) << endl;
    cout << "sizeof(char)=" << sizeof(char) << endl;
    cout << "sizeof(bool)=" << sizeof(bool) << endl;

    int i;
    cout << "sizeof(int)=" << sizeof i << endl;
    float f;
    cout << "sizeof(float)=" << sizeof f << endl;
    double d;
    cout << "sizeof(double)=" << sizeof d << endl;
    char c;
    cout << "sizeof(char)=" << sizeof c << endl;
    bool b;
    cout << "sizeof(bool)=" << sizeof b << endl;
}

/*39. 整数的基本概念

C++用int关键字来声明整型变量（int 是 integer 的简写）。
在声明整型变量的时候，可以在int关键字之前加signed、unsigned、short和long四种修饰符。
signed：有符号的，可以表示正数和负数。
unsigned：无符号的，只能表示正数，例如超女的身高和体重等。
short：短的，取值范围小，占用内存少。
long：长的，取值范围大，占用内存多。

类型简写	类型全称	长度	取值范围
short	signed short int	2字节	-32768~32767
unsigned short	unsigned short int	2字节	0~65535
int	signed int	4字节	-2147483648~2147483647
unsigned	unsigned int	4字节	0~4294967295
long	signed long int	8字节	-9223372036854775808~
9223372036854775807
unsigned long	unsigned long int	8字节	0~18446744073709551615
*/

/*40. 整数的书写
整数默认是十进制，一个表示十进制的数字不需要任何特殊的格式。

1. 二进制
二进制由 0 和 1 两个数字组成，书写时必须以0b或0B（不区分大小写）开头。
  int a = 0b101;      // 换算成十进制为 5
  int b = -0b110010;  // 换算成十进制为 -50
  int c = 0B100001;   // 换算成十进制为 33

2. 八进制
  int a = 015;      // 换算成十进制为 13
  int b = -0101;    // 换算成十进制为 -65
  int c = 0177777;  // 换算成十进制为 65535


3. 十六进制
  int a = 0X2A;   // 换算成十进制为 42
  int b = -0XA0;  // 换算成十进制为 -160
  int c = 0xffff;   // 换算成十进制为 65535



*/

/*41、C++11的long long类型

在VS中，long是4字节，32位。      -2147483648~2147483647
在Linux中，long是8字节，64位。   -9223372036854775808~9223372036854775807
C++11标准增了long long类型的整数，至少64位，且至少与long一样长。
在VS中，long long是8字节，64位。 -9223372036854775808~9223372036854775807
在Linux中，long和long long类型都是8字节，64位。

*/

/*42、浮点型（实数型）
C++浮点型分三种：float（单精度）、double（双精度）、long double（扩展精度。
三者的区别是表示有效数字的范围不同。

数据类型|	占用空间|	有效数字范围
float	4字节	7位有效数字          8位
double	8字节	15～16位有效数字    17位
long double	不少于double	不低于double         17位

注意:
1. 在VS和Linux中，long double占用的内存空间分别是8和16字节。
2. 有效数字包括了小数点前面和后面的数字。
3. C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数。
4. 浮点数的存储方法和整数不一样，比较复杂，如无必要，不用研究。（百度“为什么浮点数的小数位很多”、“为什么浮点数不精确”）
5. 在实际开发中，用整数代替浮点数，整数的运算更快，精度更高。9223372036854775807

*/

/*43. 字符型的基本概念 char

字符型（char）占用的内存空间是1个字节，书写用单引号包含。
在内存中，不存放字符本身，而是存放与它对应的编码，即ASCII码。

字符的本质：
a）字符的本质是整数，取值范围是0～127。
b）在书写的时候可以用单引号包含，也可以用整数。
c）如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。
d）可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。

思考：
e）C++为什么没有提供1字节的整型？
f）字符型也可以用unsigned修饰，意义何在？

*/

/*44. 转义字符
在C++程序中，使用转义字符的原因有两个：
- 控制字符没有符号，无法书写，只能用其它的符号代替。
- 某些符号已被C++征用，语义冲突，只能用其它的符号代替。


0	\0	空，给字符型变量赋值时可以直接书写0。
10	\n	换行(LF) ，将当前位置移到下一行开头。
13	\r	回车(CR) ，将当前位置移到本行开头
9	\t	水平制表(HT) （跳到下一个TAB位置）
92	\\	斜线
34	\"	双引号，书写字符时不必转义。
39	\'	单引号，书写字符串中不必转义。
7	\a	警报
8	\b	退格(BS) ，将当前位置移到前一列
12	\f	换页(FF)，将当前位置移到下页开头
11	\v	垂直制表(VT)

*/

void test44_main()
{
    // 换行符
    cout << "你好! \n";

    // 水平制表符 用于对其输出内容
    cout << "1 \t 小红 \n";
    cout << "100 \t 小李 \n";
}

/* 45. C++11的原始字面量
原始字面量（值）可以直接表示字符串的实际含义，不需要转义和连接。
语法：R"(字符串的内容)"
R"xxx(字符串的内容)xxx"

*/

void test45_main()
{
    {
        // 使用转义的方法
        string path = "C:\\Program Files\\Microsoft OneDrive\\tail\\nation";
        cout << "path is " << path << endl;

        // 使用C++11原始字面量
        string path1 = R"abcd(C:\Program Files\Microsoft OneDrive\tail\nation)abcd";
        cout << "path1 is " << path1 << endl;

        string str = R"(
        <no>0001</no>
        <name>西施</name>
        <sc>火树银花</sc>
        <yz>沉鱼</yz>
        <age>23</age>
        <weight>48.5</weight>
        <height>170</height>)";
        cout << str << endl;
    }
}

/*46. 字符串型

C++风格字符串：string 变量名="字符串的内容" ;
C风格字符串：char 变量名[]="字符串的内容" ;
C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。


C++风格字符串的常用操作：
- 赋值：变量名="字符串的内容" ;
- 拼接：变量名=变量名+"字符串的内容一"+"字符串的内容一"+......+"字符串的内容n" ;
如果字符串的内容都是常量，不要写加号（+），如果内容很长，可以分成多行书写。
- 比较：支持==、!=、>和<关系运算符，常用的是==和!=。
*/

void test46_main()
{
    string str = "小刘"; // 声明字符串变量并初始化。

    str = "刘yj"; // 对字符串变量重新赋值。

    cout << "请输入超女姓名："; // 输出提示文字内容。
    cin >> str;                 // 从控制台输入数据，保存在变量str中。

    if (str == "冰冰")
        cout << "我喜欢\n"; // 用==可以判断两个字符串是否相同。

    if (str != "冰冰")
        cout << "我不玩了\n";                  // 用!=可以判断两个字符串是否不相同。
    str = "姓名：" + str + "，这是我现女友。"; // 用+可以拼接多个字符串。

    // 如果字符串的内容都是常量，不要写加号（+），如果内容很长，可以分成多行书写。
    str = "超女姓名："
          "幂幂"
          "，这是我的前女友。";

    cout << str << endl;
}

/*47 布尔型
    在C和C++中，关系运算和逻辑运算的结果有两种：真和假。
    C语言用0表示假，非0表示真。
    为了提高代码的可读性，C++新增了 bool 类型，占用1字节的内存，用true表示真，false表示假。
    bool类型本质上是1字节的整数（unsigned char），取值只有1和0。
    在程序中，书写的时候可以用true和false，编译器把它们解释为1和0。
    如果对bool型变量赋非0的值，将转换成1。
    用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。
*/

/*48、数据类型的转换

计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。
在实际开发中，不同类型的数据进行混合运算是基本需求。

自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。
强制类型转换：有些类型的转换需要程序员显式指定。

1. 自动类型转换
不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。
整型从低到高：
    char -> short -> int -> long -> long long
浮点型从低到高：
    float -> double -> long double

转换法则：
- 如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动向较高类型转换。
- 当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。
- 赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
- 赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义

2. 强制类型转换
为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。

强制类型转换的语法：(目标类型)表达式或目标类型(表达式)

*/

void test48_main()
{
    // 赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。
    int d = (int)23.59; // 降低了精度。
    cout << "d=" << d << endl;

    unsigned int e = (unsigned int)4294967295 + 10; // 值被截断，从高位截断
    cout << "e=" << e << endl;
    // 4294967295         11111111111111111111111111111111
    // 4294967296 000100000000000000000000000000000000
    // 4294967297 000100000000000000000000000000000001
}

/*49 数据类型的别名 typedef or using

创建数据类型的别名有两个目的：
- 为名称复杂的类型创建别名，方便书写和记忆。
- 创建与平台无关的数据类型，提高程序的兼容性。

语法：typedef 原数据类型名 别名;

C++11还可以用using关键字创建数据类型的别名。
语法：using 别名=原数据类型名;

*/

void test49_main()
{
    // 1）为名称复杂的类型创建别名，方便书写和记忆。
    // 2）创建与平台无关的数据类型，提高程序的兼容性。
    // 在VS中，short是两个字节，int是四个字节，long也是四个字节，long long是八个字节。
    typedef short int16_t;     // 16位的整数。
    typedef int int32_t;       // 32位的整数。
    typedef long long int64_t; // 64位的整数。
    // 在Linux中，short是两个字节，int是四个字节，long也是八个字节，long long也是八个字节。
    typedef short int16_t; // 16位的整数。
    typedef int int32_t;   // 32位的整数。
    // typedef long int64_t;  // 64位的整数。

    // 在程序源代码中，只使用别名int16_t、int32_t、int64_t，不使用原名。
}

int main()
{
    // test38();
    // test44_main();
    // test45_main();

    test46_main();
    return 0;
}