#include <iostream>
#include <string>

using namespace std;

/* 50. 指针的基本概念

1. 变量的地址
变量是内存变量的简称，在C++中，
每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。
C++用运算符&获取变量在内存中的起始地址。
语法：&变量名

2. 指针变量定义

指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。
    语法：数据类型 *变量名;
数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。
星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。

3. 指针变量赋值
不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；
用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址。

    语法：指针=&变量名;

4. 指针占用内存

指针也是变量，是变量就要占用内存空间。
在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节。
在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，int*是整型指针类型，int*可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把int*当成一种数据类型就是了。

*/

/*51. 使用指针

声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。
指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）

*运算符被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值，*也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。

    int no = 38;
    int * ptr = &no;
    cout<< *no <<endl;// 38
*/

/*52. 指针用于函数参数
如果把函数的形参声明为指针，调用的时候把实参的地址传进去，
形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，
可以修改实数的值，这种方法被通俗的称为地址传递或传地址。

值传递：函数的形参是普通变量。

传地址的意义如下：
-	减少内存拷贝，提升性能。

*/

void test52(int *no, string *str)
{
    cout << "传入的no = " << *no << "传入的 str = " << *str << endl;

    *no = 100;
    *str = "Bye";
}

void test52_main()
{
    int no = 50;
    string message = "Hello";

    test52(&no, &message); // 在这里就需要传入地址， 本质还是值传入，只是这里的值是地址。
    cout << "传入后的no = " << no << "传入后的 str = " << message << endl;
}

/* 53. 用const 修饰指针

1. 常量指针（最常用）
    语法： const 数据类型 * 变量名
    const int* a
    功能： 不能通过解引用的方法修改内存地址中的值
    （用原始的变量名是可以修改的）。
    换句话说，就是指针的指向值不能通过解引用的方式被改变。

    注意：
    1. 指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
    2. 一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
    3. 如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
    4. 如果形参的值不需要改变，建议加上const修饰，程序可读性更好。

2. 指针常量
    语法： 数据类型 *const 变量名
    int *const a = 5
    功能： 指向的变量不可改变,只能指向一个地方。
    注意：
    - 在定义的同时必须初始化，否则没有意义。
    - 可以通过解引用的方法修改内存地址中的值
    - C++ 编译器把指针常量做了特别的处理，改头换面叫做“引用”

3. 常指针常量
    语法： const 数据类型 * const 变量名
    const int * const a
    指向的变量不可改变，且不能通过解引用的方式修改。

    - C++编译器将他改头换面，叫“常引用”

4. 总结
    常量指针 (const int * a) ：指针指向可以改变，指针指向的值不能改变
    指针常量（int *const a): 指针指向不可以改变，指针指向的值可以改变。
    常指针常量：指针指向不可以改，指针指向的值不可以更改。

记忆秘诀：*表示指针，指针在前先读指针；指针在前指针指向就不允许改变。
*/

void test53(const int *no, const string *str) // 不能通过解引用的方式修改传入的值
{
    cout << "传入的no = " << *no << "传入的 str = " << *str << endl;

    //*no = 100;    // 会报错
    //*str = "Bye"; // 会报错
}

void test53_main()
{
    int a = 3, b = 8;
    const int *p = &a;                            // 常量指针p指向a的地址
    cout << " a =" << a << "*p = " << *p << endl; // 两种方法显示a的值

    // 尝试通过解引用的方式修改a的值，编译器会报错
    //*p = 5;
    // 但是可以通过直接改变原始变量名去改变值
    a = 5;

    p = &b; // 指针指向的变量可以改变
    cout << "b=" << b << ", *p=" << *p << endl;

    // 声明指针常量
    int *const pc = &a;
    cout << "指针常量 pc = " << &pc << endl;
    *pc = 13; // 可以
    cout << "修改值后的指针常量 pc = " << &pc << endl;
    // pc = &b; // 让pc重新指向b会报错
}

/*54、void关键字

C++中void主要有三个用途
1. 函数返回值用void

2. 函数参数填void


3. 函数的形参用void* (重要) 表示可以接受任意数据类型的指针

注意：
- 不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。
- 不能对void *指针直接解引用（需要转换成其它类型的指针）。
- 把其它类型的指针赋值给void*指针不需要转换。
- 把void *指针赋值给把其它类型的指针需要转换。

本质：

void* 只关心地址，不关心里面的内容
*/

void test54(string varname, void *p)
{
    cout << varname << " 的地址是： " << p << endl;
    cout << varname << " 的值是 " << *(char *)p << endl; // 强制类型转换，再解引用
}

void test54_main()
{
    int a = 89;
    char b = 'x';
    cout << "a 的地址是 " << &a << endl;
    cout << "b 的地址是 " << &b << endl;

    test54("a", &a);
    test54("b", &b);
}

/* 55. C++内存模型
在 C++ 中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段。

栈：存储局部变量、函数参数和返回值。

堆：存储动态开辟内存的变量。

数据段：存储全局变量和静态变量。

代码段：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。

栈和堆的主要区别：
1）管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。
2）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。
3）分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。
4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。
5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。
6）增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。

*/

/* 55. 动态分配内存 new 和delete

使用堆区的内存有四个步骤：
1）声明一个指针；
2）用new运算符向系统申请一块内存，让指针指向这块内存；
3）通过对指针解引用的方法，像使用变量一样使用这块内存；
4）如果这块内存不用了，用delete运算符释放它。

申请内存的语法：new 数据类型(初始值);   // C++11支持{}
如果申请成功，返回一个地址；如果申请失败，返回一个空地址（暂时不考虑失败的情况）。
    释放内存的语法：delete 地址;
释放内存不会失败（还钱不会失败）。


注意：
- 动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
- 如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存。
- 动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
- 就算指针的作用域已失效，所指向的内存也不会释放。
- 用指针跟踪已分配的内存时，不能跟丢。


*/

void test55_main()
{

    int *p = new int(5);         // 在堆区new一篇int 大小的内存，赋初始值为5
    cout << "*p=" << *p << endl; // 通过指针的方式操作堆内存
    *p = 8;
    cout << "*p=" << *p << endl;
    delete p;
}

/*57. 二级指针
指针是指针变量的简称，也是变量，是变量就有地址。
指针用于存放普通变量的地址。
二级指针用于存放指针变量的地址。
声明二级指针的语法：数据类型** 指针名;
使用指针有两个目的：
1）传递地址；
2）存放动态分配的内存的地址。

在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，
形参用二级指针。
把普通变量的地址传入函数后可以在函数中修改变量的值；
把指针的地址传入函数后可以在函数中指针的值。

*/

void func(int **pp)
{

    *pp = new int(3);
    cout << "pp=" << pp << ",*pp = " << *pp << endl;
}

void test57_main()
{
    // int ii = 8;
    // cout << "ii=" << ii << ",ii的地址是：" << &ii << endl;

    // int *pii = &ii;
    // cout << "pii=" << pii << ",pii的地址是：" << &pii << ",*pii=" << *pii << endl;
    // int **ppii = &pii;
    // cout << "ppii=" << ppii << ",ppii的地址是：" << &ppii << ",*ppii=" << *ppii << endl;

    int *p;
    // 假设现在业务需要，那个内存分配单独用一个函数来处理。
    // void func(int **pp) 这里我们要传入的是 p指针的地址
    func(&p);

    cout << "p = " << p << "，*p = " << *p << endl;
}

/*58、空指针
在C和C++中，用0或NULL都可以表示空指针。
声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。

1. 使用空指针的后果

如果对空指针解引用，程序会崩溃。
如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。
在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。

为什么空指针访问会出现异常？
NULL指针分配的分区：其范围是从 0x00000000到0x0000FFFF。
这段空间是空闲的，对于空闲的空间而言，没有相应的物理存储器与之相对应，所以对这段空间来说，
任何读写操作都是会引起异常的。空指针是程序无论在何时都没有物理存储器与之对应的地址。
为了保障“无论何时”这个条件，需要人为划分一个空指针的区域，固有上面NULL指针分区。


2. C++11的nullptr

用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。
NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。
注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。




*/

void func58(int *no, string *message)
{
    if ((no == 0) || (message == 0))
        return; // 判断空指针，使得程序更加健壮
    cout << *message << *no << endl;
}
void test58_main()
{
    int *p = 0; // 或者 int*p = NULL,定义了一个空指针
    // cout << "p = " << p << ", *p=" << *p << endl; // 如果堆空指针解引用，程序会崩溃，异常退出

    int *no = new int(3);
    string *messages = new string("Hello");
    int *no_1 = 0;
    string *message_1 = 0;
    func58(no, messages);    // 正确的操作
    func58(no_1, message_1); // 错误的操作，因为在函数里面对空指针解引用了
    delete no;
    delete messages;
}

/*59 野指针
野指针就是指针指向的不是一个有效（合法）的地址。
在程序中，如果访问野指针，可能会造成程序的崩溃。

出现野指针的情况主要有三种：
1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。


2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。
3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收），
让指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针。


规避方法：
1）指针在定义的时候，如果没地方指，就初始化为nullptr。
2）动态分配的内存被释放后，将其置为nullptr。
3）函数不要返回局部变量的地址。
注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。
是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。


*/

int *func59()
{
    int a = 3;
    cout << "a =" << a << ",&a = " << &a << endl;
    return &a; // 返回了局部变量的地址，并不推荐
}

void test59_main()
{

    // int*p; //未初始化的指针
    // cout<< "p = " << p <<",*p=" << *p << endl; //会出现错误，因为 *p 没有初始化
    int *p = new int(3);
    cout << "p = " << p << ",*p=" << *p << endl;

    delete p;

    cout << "p = " << p << ",*p=" << *p << endl;
    // 如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。

    int *p2 = func59();
    cout << "p2 = " << p2 << ",*p=" << *p2 << endl; // p2 是个野指针，因为他的指向并不确定。
}

/* 60 函数指针

函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。
如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。

使用函数指针有三个步骤：
1. 声明函数指针
2. 让函数指针指向函数的地址；
3. 通过函数指针调用函数。

1.  声明函数指针
声明普通指针时，必须提供指针的类型。
同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）

比如 函数的原型是

a)
int func1(int bh,string str);
int func2(int no,string message);
int func3(int id,string info);

b)
bool func4(int id,string info);

c)
bool func5(int id);

则函数指针的声明是：
a)
int  (*pfa)(int,string); 函数指针名为 *pfa
b)
bool (*pfb)(int,string); 函数指针名为 *pfb
c)
bool (*pfc)(int); 函数指针名为 pfc

2. 函数指针的赋值
函数名就是函数的地址。
函数指针的赋值：函数指针名=函数名;

3. 函数指针的调用
(*函数指针名)(实参);
函数指针名(实参);

*/

void func(int no, string message)
{
    cout << "no = " << no << ", message = " << message << endl;
}

void test60_main()
{
    int no = 3;
    string message = " hello";

    func(no, message); // 普通调用函数的方法
    // 使用函数指针调用函数
    // 第一步，声明函数指针
    void (*pfunc)(int, string);
    // 第二步，对函数指针赋值
    pfunc = func; // 在c++中，函数名就是函数指针的地址。
    // 第三步，调用函数指针(c++写法)
    pfunc(no, message);
    // 第三步，调用函数指针(c写法)
    (*pfunc)(no, message); // c语言写法要对函数加* 和 括号
}

/*
函数指针的应用场景：

假设你开一个婚庆公司，你的任务是帮助布置现场，和清理现场，至于结婚这个事情则是由当事人去完成

所以我们这个服务的函数需要提供一个接口，让结婚的新郎新娘去执行。
至于他们是怎么去结婚，函数名是什么，我在写布置现场的函数时是不知道的，所以不可能写死，只能提供一个函数指针的接口。
这个结婚函数就是回调函数。

伪代码如下：

void 个性化结婚函数（）
{
    //新郎新娘要结婚做的事情
}

void 婚庆流程（个性化结婚函数指针p）
{
    //结婚准备工作

    个性化结婚函数指针p();

    //结婚接受后收场工作
}

*/

// 写属于 A 的 个性化结婚函数的回调函数
void marriage_cb_a(string Wife)
{
    // 个性化结婚
    cout << Wife << ", I love you,I am A" << endl;
}

// 写属于 B 的 个性化结婚函数的回调函数
void marriage_cb_b(string Wife)
{
    // 个性化结婚
    cout << Wife << ", I love you,I am B" << endl;
}

// 婚庆执行函数,执行函数中传入回调函数，因此形参是函数指针

void show(void (*pf)(string))
{
    cout << "结婚前的工作已准备完成。\n";
    pf("谁谁谁"); // 调用回调函数

    cout << "结婚后的收尾工作已完成。 \n";
}

void test60_a_main()
{
    show(marriage_cb_a);
    show(marriage_cb_b);
}

int main()
{

    test60_a_main();
}